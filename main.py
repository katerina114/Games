        # Загружаем библиотеку pygame.
import pygame                       # импортируем pygame
from random import randrange        # импортируем генератор случайных чисел

        # Создаем рабочее окно, которое будет квадратом
RES = 600
SIZE = 50

        # Создаем размер самой змейки и указываем начальное положение змейки и яблоко, которые будут случайными из нашего разрешения
x, y = randrange(SIZE, RES - SIZE, SIZE), randrange(SIZE, RES - SIZE, SIZE)
apple = randrange(SIZE, RES - SIZE, SIZE), randrange(SIZE, RES - SIZE, SIZE)
length = 1                           # Определяем длину змейки
snake = [(x, y)]                     # и саму змейку в виде списка координат

dx, dy = 0, 0                        # Это направление движения

fps = 60                             # Отвечает за скорость змейкиd

dirs = {'W': True, 'S': True, 'A': True, 'D': True, }       # Чтобы запредить змейке проходить через саму себя. Если нажали не ту клавишу, то для этого указываем словарь
                                                            # в котором изначально разрешим движение для всех клавиш
                                                            # и добавляем в управлении дополнительную проверку всех
                                                            # клавиш на нажимаемую кнопку как только какая-то клавиша
                                                            # будет нажата, тогда будем запрещать движение в обратном направлении.
                                                            # Таким образом змейка будет двигаться куда мы хотим и не съест сама себя.
score = 0                            # Одноименная переменная, которая в процессе будет увеличится на 1 ед. при съедании цели
speed_count, snake_speed = 0, 10

pygame.init()                        #  Инициализируем pygame

surface = pygame.display.set_mode([RES, RES])               # Создаем рабочее окно

clock = pygame.time.Clock()                                 # Задаем объект класс clock для регулирования скорости змейки

font_score = pygame.font.SysFont('Arial', 26, bold=True)    # Создадим шрифт и его размер для набранных очков и в связзи с этим объявим одноименную переменную, которая увеличится на ед.
font_end = pygame.font.SysFont('Arial', 66, bold=True)      # Аналогично создаем для конечной надписи

img = pygame.image.load('1.jpg').convert()                  # Закачиваем рисунок для фона

def close_game():
    for event in pygame.event.get():                        # Делаем проверку событий нашей игры
        if event.type == pygame.QUIT:                       # чтобы мы могли спокойно его завершать
            exit()

while True:
    surface.blit(img, (0, 0))                               # Отображение фонового рисунка
    # drawing snake, apple                                  # Отбразим цветами нашу змейку и яюлоко испольхуя списковые
                                                            # включения для краткости в котором пройдемся по все ее
                                                            # координатам. Правда сейчас она у нас одна секции в данном
    [pygame.draw.rect(surface, pygame.Color('green'), (i, j, SIZE - 1, SIZE - 1)) for i, j in snake]         # списке. Это ее голова.
    pygame.draw.rect(surface, pygame.Color('red'), (*apple, SIZE, SIZE))            # С яблоком сделаем тоже самое только будет у нас уже красного цвета.
                                                                                    # Координаты яблоко будет распаковывать в области квадрата
    # show score
    render_score = font_score.render(f'SCORE: {score}', 1, pygame.Color('orange'))  # Зарендерим надпись. Выберем оранжевый цвет
    surface.blit(render_score, (5, 5))                                              # и разместим ее в верхнем левом углу
    # snake movement                                        # Определяем движение нашей змейки
    speed_count += 1
    if not speed_count % snake_speed:
	    x += dx * SIZE                                      # 1 ее шаг будет равен расстоянию ее головы
	    y += dy * SIZE
	    snake.append((x, y))                                # и каждый шаг будем добавлять в ее список координат
	    snake = snake[-length:]                             # Чтобы змейка была нужного размера, делаем срез ее координат
                                                            # в соответствии со значением ее переменной, отвечающую за ее длину
                                                            # У нас длина змейки равна 1, поэтому видна только ее голова
    # eating food                                           # Рассмотрим случай поедания яблако. Голова змейки - это крайний
    if snake[-1] == apple:                                  # элемент в списке ее координат. Когда он равен положению яблоко,
                                                            # то выходит, что мы его съели
        apple = randrange(SIZE, RES - SIZE, SIZE), randrange(SIZE, RES - SIZE, SIZE)
        length += 1                                         # и в связи с этим увеличиваем скорость на одну ед.
        score += 1                                          # # Одноименная переменная, которая в процессе будет увеличится на 1 ед. при съедании цели
        snake_speed -= 1
        snake_speed = max(snake_speed, 4)
            # game over                                     # Теперь определим случай, когда мы проиграли
    if x < 0 or x > RES - SIZE or y < 0 or y > RES - SIZE or len(snake) != len(set(snake)):     # Первый случай - когла
                                                                                                # змейка вышла за предеды поля.
                                                                                                # Определяем крайнее положение поля
                                                                                                # для x и y  и в этих случаях обрываем
                                                                                                # главный цикл, а вот второй случай, когда съели себя.
                                                                                                # При таком положении дел появится дублирущая координата
                                                                                                # в списке координат змейки. Для этого сравним длину
                                                                                                # списка с длиной множества, взятого с этого списка в случае,
                                                                                                # когда они не равны, т.е. тогда, когда змейка съела себя
        while True:
            render_end = font_end.render('GAME OVER', 1, pygame.Color('orange'))     # Вместо завершения главного цикла вставим еще один цикл в котором отрендерим надпись
            surface.blit(render_end, (RES // 2 - 200, RES // 3))                     # включая туда же проверку на закрытие приложения
            pygame.display.flip()
            close_game()

    pygame.display.flip()                       # Обновляем поверхность
    clock.tick(fps)                             # и задаем задержку для fps
    close_game()

    # controls                                   # Управление змейки. Делаем информацию  о всех нажатых клавишах
    key = pygame.key.get_pressed()               # Сделаем управление на клавиши W - вверх, A - влево, S - вниз, D - вправо
    if key[pygame.K_w]:
        if dirs['W']:
            dx, dy = 0, -1                       # Под каждую кнопку назанчаем соответствующие dx и dy, которые отвечают за управление движения змейки
            dirs = {'W': True, 'S': False, 'A': True, 'D': True, }
    elif key[pygame.K_s]:
        if dirs['S']:
            dx, dy = 0, 1
            dirs = {'W': False, 'S': True, 'A': True, 'D': True, }
    elif key[pygame.K_a]:
        if dirs['A']:
            dx, dy = -1, 0
            dirs = {'W': True, 'S': True, 'A': True, 'D': False, }
    elif key[pygame.K_d]:
        if dirs['D']:
            dx, dy = 1, 0
            dirs = {'W': True, 'S': True, 'A': False, 'D': True, }
